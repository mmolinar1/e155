/*
File: ai_proto.c
Author: Matthew Molinar
Email: mmolinar@hmc.edu
Date: 10/14/2025

This is code generated by the Chat GPT using
the AI Prototype promt
*/

#include "stm32l432xx.h"

#define DS1722_READ_CMD     0x02  // Read temperature MSB register
#define DS1722_WRITE_CMD    0x80  // Write command prefix
#define DS1722_TEMP_MSB_REG 0x02  // Temperature MSB register address
#define DS1722_TEMP_LSB_REG 0x01  // Temperature LSB register address

// SPI1 pins assumed: 
//   PA5 -> SCK, PA6 -> MISO, PA7 -> MOSI, PA4 -> NSS
//   Modify if you’re using a different configuration.

static inline void SPI1_Init(void)
{
    // Enable GPIOA and SPI1 clocks
    RCC->AHB2ENR |= RCC_AHB2ENR_GPIOAEN;
    RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;

    // PA5 (SCK), PA6 (MISO), PA7 (MOSI), PA4 (NSS)
    GPIOA->MODER &= ~(GPIO_MODER_MODE4_Msk | GPIO_MODER_MODE5_Msk |
                      GPIO_MODER_MODE6_Msk | GPIO_MODER_MODE7_Msk);
    GPIOA->MODER |= (2U << GPIO_MODER_MODE5_Pos) |   // AF mode for SCK
                    (2U << GPIO_MODER_MODE6_Pos) |   // AF mode for MISO
                    (2U << GPIO_MODER_MODE7_Pos);    // AF mode for MOSI
    GPIOA->MODER |= (1U << GPIO_MODER_MODE4_Pos);    // Output mode for NSS

    GPIOA->AFR[0] &= ~((0xF << GPIO_AFRL_AFSEL5_Pos) |
                       (0xF << GPIO_AFRL_AFSEL6_Pos) |
                       (0xF << GPIO_AFRL_AFSEL7_Pos));
    GPIOA->AFR[0] |= (5U << GPIO_AFRL_AFSEL5_Pos) |  // AF5 for SPI1
                     (5U << GPIO_AFRL_AFSEL6_Pos) |
                     (5U << GPIO_AFRL_AFSEL7_Pos);

    // Configure NSS as high (inactive)
    GPIOA->BSRR = GPIO_BSRR_BS4;

    // Configure SPI1 in master mode, 8-bit, fPCLK/8
    SPI1->CR1 = SPI_CR1_MSTR | SPI_CR1_SSI | SPI_CR1_SSM | (2U << SPI_CR1_BR_Pos);
    SPI1->CR2 = 0; // Default 8-bit, no NSS pulse
    SPI1->CR1 |= SPI_CR1_SPE;
}

static inline uint8_t SPI1_Transfer(uint8_t data)
{
    while (!(SPI1->SR & SPI_SR_TXE));  // Wait for TX buffer empty
    *((__IO uint8_t *)&SPI1->DR) = data; // Write data
    while (!(SPI1->SR & SPI_SR_RXNE)); // Wait for RX buffer full
    return *((__IO uint8_t *)&SPI1->DR);
}

float DS1722_ReadTemperature(void)
{
    uint8_t msb, lsb;
    int16_t raw;
    float temperature;

    // Pull NSS low
    GPIOA->BSRR = GPIO_BSRR_BR4;

    // Send read command and register address
    SPI1_Transfer(DS1722_TEMP_MSB_REG);
    msb = SPI1_Transfer(0x00);

    // Some DS1722s require reading both bytes separately
    SPI1_Transfer(DS1722_TEMP_LSB_REG);
    lsb = SPI1_Transfer(0x00);

    // Pull NSS high
    GPIOA->BSRR = GPIO_BSRR_BS4;

    // Combine 8.8 fixed-point format (MSB: integer, LSB: fraction)
    raw = ((int16_t)msb << 8) | lsb;
    temperature = (float)raw / 256.0f; // Each LSB = 1/256 °C

    return temperature;
}
